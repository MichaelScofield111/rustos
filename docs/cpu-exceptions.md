## CPU Exceptions
CPU异常在很多情况下都有可能发生，比如访问无效的内存地址，或者在除法运算里除以0。为了处理这些错误，我们需要设置一个`中断描述符表`来提供异常处理函数。
### introduction
异常信号会在当前指令触发错误时被触发，例如执行了除数为0的除法。当异常发生后，CPU会中断当前的工作，并立即根据异常类型调用对应的错误处理函数。
<br>
在x86架构中，存在20种不同的CPU异常类型，以下为最重要的几种：
- `Page Fault`: 页错误是被非法内存访问触发的，例如当前指令试图访问未被映射过的页，或者试图写入只读页。
- `Invalid Opcode`: 该错误是说当前指令操作符无效，比如在不支持SSE的旧式CPU上执行了 SSE 指令。
- `General Protection Fault`: 该错误的原因有很多，主要原因就是权限异常，即试图使用用户态代码执行核心指令，或是修改配置寄存器的保留字段。
- `Double Fault`: 当错误发生时，CPU会尝试调用错误处理函数，但如果 在调用错误处理函数过程中 再次发生错误，CPU就会触发该错误。另外，如果没有注册错误处理函数也会触发该错误。
- `Triple Fault`: 如果CPU调用了对应 Double Fault 异常的处理函数依然没有成功，该错误会被抛出。这是一个致命级别的 三重异常，这意味着我们已经无法捕捉它，对于大多数操作系统而言，此时就应该重置数据并重启操作系统。

### 中断描述符
要捕捉CPU异常，我们需要设置一个 中断描述符表 (Interrupt Descriptor Table, IDT)，用来捕获每一个异常。由于硬件层面会不加验证的直接使用，所以我们需要根据预定义格式直接写入数据。符表的每一行都遵循如下的16字节结构。

| 类型   | 名称                         | 描述                                                         |
|--------|------------------------------|--------------------------------------------------------------|
| u16    | Function Pointer [0:15]      | 处理函数地址的低位（最后16位）                               |
| u16    | GDT selector                 | 全局描述符表中的代码段标记。                                 |
| u16    | Options                      | 详情见下表。                                                 |
| u16    | Function Pointer [16:31]     | 处理函数地址的中位（中间16位）。                             |
| u32    | Function Pointer [32:63]     | 处理函数地址的高位（剩下的所有位）。                         |
| u32    | Reserved                     | 保留字段。                                                   |

Options 字段的格式

| Bits | Name                        | Description                                                  |
|------|-----------------------------|--------------------------------------------------------------|
| 0-2  | Interrupt Stack Table Index  | 0: 不要切换栈, 1-7: 当处理函数被调用时，切换到中断栈表的第n层。|
| 3-7  | Reserved                    | 保留位。                                                     |
| 8    | 0: Interrupt Gate, 1: Trap Gate | 如果该比特被置为0，当处理函数被调用时，中断会被禁用。       |
| 9-11 | must be one                 | 必须设置为1。                                                |
| 12   | must be zero                | 必须设置为0。                                                |
| 13-14| Descriptor Privilege Level (DPL) | 执行处理函数所需的最小特权等级。                           |
| 15   | Present                     | 设置为1表示该描述符在内存中存在。                            |

每个异常都具有一个预定义的IDT序号，比如 invalid opcode 异常对应6号，而 page fault 异常对应14号，因此硬件可以直接寻找到对应的IDT条目。
<br>
通常而言，当异常发生时，CPU会执行如下步骤：
1. 将一些寄存器数据入栈，包括指令指针以及 RFLAGS 寄存器。（我们会在文章稍后些的地方用到这些数据。）
2. 读取中断描述符表（IDT）的对应条目，比如当发生 page fault 异常时，调用14号条目。
3. 判断该条目确实存在，如果不存在，则触发 double fault 异常。
4. 如果该条目属于中断门（interrupt gate，bit 40 被设置为0），则禁用硬件中断。
5. 将 GDT 选择器载入代码段寄存器（CS segment）。
6. 跳转执行处理函数。

### 中断调用约定
异常触发十分类似于函数调用：CPU会直接跳转到处理函数的第一个指令处开始执行，执行结束后，CPU会跳转到返回地址，并继续执行之前的函数调用。
<br>
然而两者最大的不同点是：函数调用是由编译器通过 call 指令主动发起的，而错误处理函数则可能会由 任何 指令触发。
<br>
调用约定 指定了函数调用的详细信息，比如可以指定函数的参数存放在哪里（寄存器，或者栈，或者别的什么地方）以及如何返回结果。在 x86_64 Linux 中，以下规则适用于C语言函数（指定于 System V ABI 标准）：
- 前六个整型参数从寄存器传入 rdi, rsi, rdx, rcx, r8, r9
- 其他参数从栈传入
- 函数返回值存放在 rax 和 rdx
注意，Rust并不遵循C ABI，而是遵循自己的一套规则，即 尚未正式发布的 Rust ABI 草案，所以这些规则仅在使用 extern "C" fn 对函数进行定义时才会使用。

### Perserved and Scratch Registers
调用约定将寄存器分为两部分：保留寄存器 和 临时寄存器 。
<br>
保留寄存器 的值应当在函数调用时保持不变，所以被调用的函数（ “callee” ）只有在保证“返回之前将这些寄存器的值恢复到初始值“的前提下，才被允许覆写这些寄存器的值， 在函数开始时将这类寄存器的值存入栈中，并在返回之前将之恢复到寄存器中是一种十分常见的做法。
<br>
而 临时寄存器 则相反，被调用函数可以无限制的反复写入寄存器，若调用者希望此类寄存器在函数调用后保持数值不变，则需要自己来处理备份和恢复过程（例如将其数值保存在栈中），因而这类寄存器又被称为 caller-saved。
<br>
在 x86_64 架构下，C调用约定指定了这些寄存器分类：
| 分类       | 寄存器列表                          |
|------------|-------------------------------------|
| 保留寄存器 (callee-saved) | `rbp`, `rbx`, `rsp`, `r12`, `r13`, `r14`, `r15` |
| 临时寄存器 (caller-saved) | `rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8`, `r9`, `r10`, `r11` |

编译器已经内置了这些规则，因而可以自动生成保证程序正常执行的指令。例如绝大多数函数的汇编指令都以 push rbp 开头，也就是将 rbp 的值备份到栈中（因为它是 callee-saved 型寄存器）。